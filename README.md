# cybersec-project
A repository for the Cyber Security MOOC practice assignment.



LINK: https://github.com/joonasviljakainen/cybersec-project
Installation is easy. Clone the project and run `mvn spring-boot:run`.

FLAW 1:
Stored XSS vulnerability. Any user can use the address field of the signup to inject e.g. Javascript, which will allow the execution of arbitrary code in the browser. For example, one could insert `<SCRIPT>alert("Hello security!");</SCRIPT>` to the address field to force an annoying greeting on all users who see the signup in question.
FIX: The rendering template should be modified to escape all user-input data. Alternatively (and in addition), user input should be sanitized before storing it in the database. Unsanitized user input is always a massive security risk and should be avoided even if the rendering engine can avoid the execution of hidden scripts. Finally, to mitigate the damage caused by an XSS vulnerability, the application should store as little sensitive (i.e. stealable) data as possible on the browser-side, and ensure that e.g. cookies are set as HTTP only to prevent them from falling in the wrong hands.

FLAW 2:
Broken access control. Signups that have been created can be viewed only by a signed-in user, but the programmer has made an error: only the endpoint "/signups" is restricted, "/signups/{id}" is not. This exposes all names and addresses in the database, as the ID value of each signup is an integer. The signups are very easy to view and navigate, and could be scraped with a simple script. In addition, sessions are very long, on the order of about a week - in other words, if a person signs in without explicitly logging out, there is a high risk that another person using the same computer can continue with the previous person still signed in.
FIX: Firstly, the URL pattern "/signups/*" needs to be added to the list of pages requiring authentication in the security configuration file (SecurityConfiguration.java). The authentication requirements of each page must be considered and set carefully. Automated tests can be used to ensure that the configurations are set as intended. In addition, providing element navigation with simple integers as URL IDs provides a larger attack surface: in the case of an incorrectly configured page, it is extremely easy to explore and exploit the exposed data. Therefore integer IDs should not be used, and a more sustainable approach should be adopted (at least in production). Session length should be limited with a reasonable expiration time (e.g. the user could be signed out after 15 minutes of being idle).

FLAW 3:
Bad password storage. Currently, the application makes use of a custom password encoder stub which stores passwords in plaintext. This obviously poses a great risk of misuse following a possible break-in and extraction. Corresponds to OWASP title "Sensitive data exposure".
FIX: Passwords should always be hashed, and whenever possible they should be salted as well. For best results, it is recommended to use BCrypt or any other well-known, up-to-date and maintained library for processing, storing, and validating passwords. 
On a related note, I was happy to find out that in newest versions of Spring Boot passwords are hashed by default - in other words, it require nontrivial effort on behalf of the programmer to create an unsafe password storage. In this case, staying up-to-date definitely helps in safeguarding user data.

FLAW 4: 
Broken authentication. The applications provides a registration page at address /register. In its current state, the application 1. Does not ensure that usernames are unique, resulting in duplicate accounts and/or overridden credentials (i.e. the same username may or may not "have" two passwords) 2. Sets constraints neither on usernames nor on passwords, which may lead to very weak passwords. In addition, as the input is not validated in any way, it may contain characters that the system cannot handle.
FIX: 1. Set usernames as unique. This can be achieve either by using appropriate Spring annotations or by searching the database for existing accounts under the same name in the registration method. 2. Passwords and usernames should have apporoproate minimum lengths. It is recommended to validate the password in some way, e.g. against a list of well-known, common passwords. The user should be encouraged to use long passwords that are easy to remember instead of short ones with numbers and symbols that are difficult to recall. The length of the password is much more important than its complexity - passphrases made up of random words have much more entropy than short but complicated character blobs.

FLAW 5:
Insufficient logging. The application programmer has the right idea: they want to see what is happening in the application as it is being used. They have implemented simple logging for most actions. But there are few flaws: Even though individual actions are being logged, they provide no clue as to who made those actions. No comment is made on whether the user was authorized or not. Secondly, there is no error logging. An attacker could try to log in as many times as they want to, with no trace left in the logs. In addition, the logs are not stored anywhere - as the application stops, the logs vanish.
FIX: Logging can be improved in the following ways: 1. In addition to individual actions, include user IDs and the action targets (e.g. values changed by the user) in the logs. 2. Use interaction IDs in the logs, and use these interaction IDs to trace individual failed interactions - a great help in debugging. 3. Store logs in an secure external service. 4. Log errors with sufficient information for tracking the error and its cause. 5. Implement an alert system to ensure high error rates do not go unseen.
